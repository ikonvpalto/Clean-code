# Введение

Единственная надежная метрика качества кода - количество "чертей" в минуту. Знания и опыт. 

# Глава 1: Чистый код

## Да будет код

Код никогда не исчезнет потому, что он является описанием требований, полным и точным в деталях. Рост уровня абстракций языков и числа предметно-ориентированных языков только увеличивают размер строительных блоков (кирпич -> панель -> квартирный блок -> ...), но параллельно с этим растут и масштабы приложений (отдельный небольшой дом -> многоквартирный дом -> небоскреб -> квартал -> ...). Требования изначальные уточняются до тех пор, пока их нельзя будет записать в виде кода. Точно определенные требования могут использоваться как тесты для кода (Cucumber, BDD). 

*Примечание*: рост размера строительных блоков и стройки зависит от аппаратной части (а точнее, скорость ее улучшения). Пока она позволяет интенсивный рост размера. Как только реальные данные начнут отставать от закона Мура, придется начать больше уделять время экстенсивному развитию, профессия программиста начнет становиться сложнее, а для поддержания бОльших строек придется возвращаться к более мелким строительным блокам.   

## Плохой код

Плохой код привел к краху компании. Но и упарываться слишком в качество кода не стоит: этим можно заниматься до бесконечности не придя к результату. Нужно придерживаться золотой середины. Потом = никогда (правило Леблана). Но только если это простое "потом". Ибо оно забывается и пропадает. Чтобы оно не стало никогда, надо сделать его мозолящим глаз, портящим идеальную статистику, ...

## Расплата за хаос

Больше хаоса -> меньше производительность команды -> больше давления -> еще меньше производительность и больше хаоса

## Грандиозная переработка

... -> переписывание системы

И новый вариант постепенно попадают на старый цикл ухудшения кода и производительности команды

## Отношение

В попадании в этот цикл не стоит винить внешние обстоятельства (начальника, клиентов, сроки, давление): вставание на этот цикл не единственный способ реагировать на это. Можно, например, сказать, что нужно потратить такое-то количество времени на улучшение текущей системы и доказать, что это необходимо. Начальник и пользователи понятия не имеют, что творится внутри кодовой базы. А разработчики - имеют. И поэтому ответственны за качество кода. А при его отсутствии, за маленькую скорость, просраные дедлайны, ...
Начальники могут страстно защищать график и требования; но это их работа. А ваша работа — так же страстно защищать код. Ибо мы знаем и понимаем опасность не отведения времени на чистку. Таким образом, программист, который подчиняется воле начальника, не понимающего опасность некачественного кода, проявляет непрофессионализм.

*Примечание*: Но думать только о качестве кода тоже неправильно. Надо думать о функциональности системы, затраченных средствах, ... Чем больше направлений улучшения системы программист может держать в голове и принимать решения, у какого направления какой приоритет в определенной ситуации (учитывая не только текущий момент времени, а еще и будущее), тем он лучше.

## Основной парадокс

Нет времени, чтобы работать быстро.

## Искусство чистого кода

Не существует функции, которая принимает на вход код, а на выход дает точную оценку кода: NP-полная задача с огромным объемом входных данных. И, как и любую другую NP-полную задачу, ее можно решить с некоторой точностью используя некоторый набор правил для частных случаев и одного эвристического алгоритма. Правила - code smells, шаблоны проектирования и архитектурные шаблоны, которые помнит программист. Эвристический алгоритм - "чувство кода", выработанное программистом из собственного опыта.   

## Что такое "чистый код"?

> Я люблю, чтобы мой код был **элегантным** и **эффективным**. **Логика** должны быть достаточно **прямолинейной**, чтобы ошибкам было трудно спрятаться; **зависимости — минимальными**, чтобы упростить сопровождение; **обработка ошибок — полной в соответствии с выработанной стратегией**; а **производительность — близкой к оптимальной**, чтобы не искушать людей загрязнять код беспринципными оптимизациями. **Чистый код хорошо решает одну задачу**

Одно разбитое окно ведет к изуродованному зданию.

>  Чистый код **читается, как хорошо написанная проза**. Чистый код никогда **не затемняет намерения** проектировщика; он полон **четких абстракций** и **простых линий передачи управления**.

> Чистый код **может читаться и усовершенствоваться другими разработчиками**, кроме его исходного автора. Для него написаны модульные и приемочные **тесты**. В чистом коде используются **содержательные имена**. **Для** выполнения **одной операции** в нем используется **один путь** (вместо нескольких разных). Чистый код обладает **минимальными зависимостями, которые явно определены**, и **четким, минимальным API**. Код должен быть грамотным, потому что в зависимости от языка не вся необходимая информация может быть четко выражена в самом коде.

Чем меньше, тем лучше.

Грамотное программирование - подход, при котором во главе угла не объяснение машине, что нужно сделать, а читающему код программисту идею, которую вкладывает автор.

> **Чистый код всегда выглядит так, словно его автор над ним тщательно потрудился.** Вы не найдете никаких очевидных возможностей для его улучшения. Все они уже были продуманы автором кода. Попытавшись представить возможные усовершенствования, вы снова придете к тому, с чего все началось: вы рассматриваете код, тщательно продуманный и написанный настоящим мастером, небезразличным к своему ремеслу.

> В порядке важности, простой код: 
> * проходит все тесты; 
> * не содержит дубликатов; 
> * выражает все концепции проектирования, заложенные в систему; 
> * содержит минимальное количество сущностей: классов, методов, функций и т. д.
>
>  **Сокращение дублирования, высокая выразительность и раннее построение простых абстракций**

> Вы работаете с чистым кодом, если **каждая функция делает примерно то, что вы ожидали**. Код можно назвать красивым, если у вас также **создается впечатление, что язык был создан специально для этой задачи**.

## Мы - авторы

Написать код не прочитав его невозможно: постоянно приходится прыгать в разные концы базы. Упрощение чтения ведет за собой ускорение написания.

## Правило бойскаута

Оставь место стоянки чище, чем оно было до твоего прихода. (Слово оставь используется в единственном числе, указывая на личную ответственность, которая не должна зависеть от того, что делают окружающие)

# Глава 2: Содержательные имена

* Имена должны передавать намерения программиста
   * Следить за именами в проекте
   * Должно отвечать на вопросы: зачем она, что делает и как используется
   * Комментарий -> название не передает намерение
* Избегайте дезинформации 
   * Не должно быть скрытых значений, отличных от предполагаемого
   * Избегать малозаметных различий в именах 

