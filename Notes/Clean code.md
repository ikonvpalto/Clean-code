# Введение

Единственная надежная метрика качества кода - количество "чертей" в минуту. Знания и опыт. 

# Глава 1: Чистый код

## Да будет код

Код никогда не исчезнет потому, что он является описанием требований, полным и точным в деталях. Рост уровня абстракций языков и числа предметно-ориентированных языков только увеличивают размер строительных блоков (кирпич -> панель -> квартирный блок -> ...), но параллельно с этим растут и масштабы приложений (отдельный небольшой дом -> многоквартирный дом -> небоскреб -> квартал -> ...). Требования изначальные уточняются до тех пор, пока их нельзя будет записать в виде кода. Точно определенные требования могут использоваться как тесты для кода (Cucumber, BDD). 

*Примечание*: рост размера строительных блоков и стройки зависит от аппаратной части (а точнее, скорость ее улучшения). Пока она позволяет интенсивный рост размера. Как только реальные данные начнут отставать от закона Мура, придется начать больше уделять время экстенсивному развитию, профессия программиста начнет становиться сложнее, а для поддержания бОльших строек придется возвращаться к более мелким строительным блокам.   

## Плохой код

Плохой код привел к краху компании. Но и упарываться слишком в качество кода не стоит: этим можно заниматься до бесконечности не придя к результату. Нужно придерживаться золотой середины. Потом = никогда (правило Леблана). Но только если это простое "потом". Ибо оно забывается и пропадает. Чтобы оно не стало никогда, надо сделать его мозолящим глаз, портящим идеальную статистику, ...

## Расплата за хаос

Больше хаоса -> меньше производительность команды -> больше давления -> еще меньше производительность и больше хаоса

## Грандиозная переработка

... -> переписывание системы

И новый вариант постепенно попадают на старый цикл ухудшения кода и производительности команды

## Отношение

В попадании в этот цикл не стоит винить внешние обстоятельства (начальника, клиентов, сроки, давление): вставание на этот цикл не единственный способ реагировать на это. Можно, например, сказать, что нужно потратить такое-то количество времени на улучшение текущей системы и доказать, что это необходимо. Начальник и пользователи понятия не имеют, что творится внутри кодовой базы. А разработчики - имеют. И поэтому ответственны за качество кода. А при его отсутствии, за маленькую скорость, просраные дедлайны, ...
Работа начальника - защищать график и требования, программиста — защищать код. Ибо мы знаем и понимаем опасность не отведения времени на чистку. Таким образом, программист, который подчиняется воле начальника, не понимающего опасность некачественного кода, проявляет непрофессионализм.

*Примечание*: Но думать только о качестве кода тоже неправильно. Надо думать о функциональности системы, затраченных средствах, ... Чем больше направлений улучшения системы программист может держать в голове и принимать решения, у какого направления какой приоритет в определенной ситуации (учитывая не только текущий момент времени, а еще и будущее), тем он лучше.

## Основной парадокс

Нет времени, чтобы работать быстро.

## Искусство чистого кода

Не существует функции, которая принимает на вход код, а на выход дает точную оценку кода: NP-полная задача с огромным объемом входных данных. И, как и любую другую NP-полную задачу, ее можно решить с некоторой точностью используя некоторый набор правил для частных случаев и одного эвристического алгоритма. Правила - code smells, шаблоны проектирования и архитектурные шаблоны, которые помнит программист. Эвристический алгоритм - "чувство кода", выработанное программистом из собственного опыта.   

## Что такое "чистый код"?

> Я люблю, чтобы мой код был **элегантным** и **эффективным**. **Логика** должны быть достаточно **прямолинейной**, чтобы ошибкам было трудно спрятаться; **зависимости — минимальными**, чтобы упростить сопровождение; **обработка ошибок — полной в соответствии с выработанной стратегией**; а **производительность — близкой к оптимальной**, чтобы не искушать людей загрязнять код беспринципными оптимизациями. **Чистый код хорошо решает одну задачу**

Одно разбитое окно ведет к изуродованному зданию.

>  Чистый код **читается, как хорошо написанная проза**. Чистый код никогда **не затемняет намерения** проектировщика; он полон **четких абстракций** и **простых линий передачи управления**.

> Чистый код **может читаться и усовершенствоваться другими разработчиками**, кроме его исходного автора. Для него написаны модульные и приемочные **тесты**. В чистом коде используются **содержательные имена**. **Для** выполнения **одной операции** в нем используется **один путь** (вместо нескольких разных). Чистый код обладает **минимальными зависимостями, которые явно определены**, и **четким, минимальным API**. Код должен быть грамотным, потому что в зависимости от языка не вся необходимая информация может быть четко выражена в самом коде.

Чем меньше, тем лучше.

Грамотное программирование - подход, при котором во главе угла не объяснение машине, что нужно сделать, а читающему код программисту идею, которую вкладывает автор.

> **Чистый код всегда выглядит так, словно его автор над ним тщательно потрудился.** Вы не найдете никаких очевидных возможностей для его улучшения. Все они уже были продуманы автором кода. Попытавшись представить возможные усовершенствования, вы снова придете к тому, с чего все началось: вы рассматриваете код, тщательно продуманный и написанный настоящим мастером, небезразличным к своему ремеслу.

> В порядке важности, простой код: 
> * проходит все тесты; 
> * не содержит дубликатов; 
> * выражает все концепции проектирования, заложенные в систему; 
> * содержит минимальное количество сущностей: классов, методов, функций и т. д.
>
>  **Сокращение дублирования, высокая выразительность и раннее построение простых абстракций**

> Вы работаете с чистым кодом, если **каждая функция делает примерно то, что вы ожидали**. Код можно назвать красивым, если у вас также **создается впечатление, что язык был создан специально для этой задачи**.

## Мы - авторы

Написать код не прочитав его невозможно: постоянно приходится прыгать в разные концы базы. Упрощение чтения ведет за собой ускорение написания.

## Правило бойскаута

Оставь место стоянки чище, чем оно было до твоего прихода. (Слово оставь используется в единственном числе, указывая на личную ответственность, которая не должна зависеть от того, что делают окружающие)

# Глава 2: Содержательные имена

* Имена должны передавать намерения программиста
   * Следить за именами в проекте
   * Должно отвечать на вопросы: зачем она, что делает и как используется
   * Комментарий -> название не передает намерение
* Избегайте дезинформации 
   * Не должно быть скрытых значений, отличных от предполагаемого
      * `acoountList` только если используется `List`, иначе `accounts` или `accountCollection` (последнее - если нет частоиспользуемого класса `Collection`) 
   * Избегать малозаметных различий в именах 
* Используйте осмысленные различия
   * Отсутствие ворнингов компилятора и проблем в коде от статического анализатора - не цель. Цель - сделать код чистым.
      * Добавление незначящих приставок (цифры, подчеркивания, `Info`, `Data`, иногда `Manager`) - плохая идея
   * Не добавлять в название части, которые выводятся из остальной части имени (`Name`**`String`**)
* Используйте легко произносимые имена
   * Прога - занятие социальное
* Используйте имена, которые легко искать
   * Автодополнение
   * Однобуквенные, в этом плане плохи. Но только в глобальном контексте. Если она ничего уникально полезного не несет особо (i), то ок (не ок, на самом деле)
   * Длинна имени должна соответствовать размеру её области видимости 
   * Переменные-константы лучше магических чисел/строк/этц 
* Избегайте схем кодирования
* Избегайте мысленных преобразований
   * Использование одного названия для переменной, когда переменная обозначает что-то другое, весьма вредно.
   * Имя класса - название сущности, существительные, не использовать в имени глагол и отглагольные слова 
   * Имена методов - глаголы и отглагольные слова. 
   * При перегрузке конструктора, возможно, будет оч полезно сделать их приватными и добавить именованые статические функции-фабрики с подходящими для параметров именами
* Имена должны быть понятны для людей из другой культурной среды
   * Но можно (и нужно) использовать то, что точно принадлежит к культуре программистов (`Factory` будет точно что-то создавать) или культуре задачи (`Property` в приложении, связанном с недвижимостью, будет содержать информацию о жилом помещении)
* Единый лексикон
   * Одна концепция - одно имя
   * Разные концепции - разные имена, никаких каламбуров (если есть `add`=конкатенация, то добавлять `add`=добавить в коллекцию - не хорошо)
* Контекст важен
   * Добавте содержательный контекст, без него большинство имен могу иметь несколько смыслов (добавление контекста в имя может привести к слишком большому имени, можно использовать объединение в отдельный класс, метод, ...)
   * Но не перебарщивать с контекстами (Некоторые сущности могут существовать вне каких-то контекстов и будут только лучше пониматься: класс физического адреса не стоит привязывать к контексту приложения)

Хорошиое именование = хорошие описательные способности и придерживание рамок общего культурного фона